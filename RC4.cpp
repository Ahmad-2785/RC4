#include <iostream>
#include <cmath>

using namespace std;

void generateRandomKey(int Key[128]){
    // Function to generate a random 128-bit key in binary, just 0s and 1s, using random function
    for (int i = 0; i < 128; i++){
        // To be sure that the result is either 0 or 1
        Key[i] = rand() % 2;
    }
}

void probabilityOfSecondZero( int Key[128], int S[256], int T[256], int generationsNo){
    // Function to calculate the probability of the second byte being zero in a sequence
    // Initialize S and T arrays
    for (int i = 0; i < 256; i++) {
        // Set the S values to be from 0 to 255
        S[i] = i;
        // Here the 128 is the length of the key
        T[i] = Key[i % 128];
    }

    // Initialize variables i, j, t, val, and count.
    int i = 0, j = 0, t, val, count = 0;
    for (int iter = 0; iter < generationsNo; iter++){
        // Loop for 'generationsNo' iterations, which represents the number of generations
        // of pseudo-random bytes to generate (The number of times to generate 2 bytes)

        // This inner loop iterates twice to perform two bytes.
        for (int n = 0; n < 2; n++){
            i = (i + 1) % 256;
            // Update variable 'i' by incrementing it and ensuring it wraps around within the range [0, 255].

            j = (j + S[i]) % 256;
            // Update variable 'j' using the value from the 'S' array and wrapping it within [0, 255].

            swap(S[i], S[j]);
            t = (S[i] + S[j]) % 256;
            // Calculate variable 't' by adding 'S[i]' and 'S[j]' and wrapping it within [0, 255].

            val = S[t];
            // Get the pseudo-random byte value 'val' from the 'S' array at position 't'.

        }
        // When we out of the inner loop the value in val is the second generated byte, so we test if it's 0
        if (val == 0)
            count++;
    }
    // Output the probability of generating 2 bytes with the second one being zero
    cout << "The probability of generating 2 bytes the second one being zero " << generationsNo << " times : "
         << count / (generationsNo * 1.0) << endl; 
    // We divide the number of having second byte equal to 0 on the number of generated keys.
}

void probabilityOfTwoZeros( int Key[128], int S[256], int T[256], int generationsNo){
    // generationsNo: the number of bytes to be generated
    // Initialize the S and T arrays with values from the provided 'Key' and sequence numbers
    for (int i = 0; i < 256; i++) {
        S[i] = i;
        T[i] = Key[i % 128];
    }

    int i = 0, j = 0, t, val, count = 0;
    // Initialize variables for the RC4 algorithm and a counter for occurrences of two consecutive zeros.
    bool previousValIsZero = false;
    // A boolean flag to keep track of whether the previous 'val' was zero.

    for (int n = 0; n < generationsNo; n++){
        // Loop for 'generationsNo' iterations to generate pseudo-random bytes.

        i = (i + 1) % 256;
        // Update variable 'i' by incrementing it and ensuring it wraps around within the range [0, 255].

        j = (j + S[i]) % 256;
        // Update variable 'j' using the value from the 'S' array and wrapping it within [0, 255].

        swap(S[i], S[j]);
        t = (S[i] + S[j]) % 256;
        // Calculate variable 't' by adding 'S[i]' and 'S[j]' and wrapping it within [0, 255].

        val = S[t];
        // Get the pseudo-random byte value 'val' from the 'S' array at position 't'.

        if (val == 0 && previousValIsZero){
            // Check if the current 'val' is zero and if the previous 'val' was also zero.
            count++; // Increment the 'count' to track the occurrence of two consecutive zeros.
        }
        previousValIsZero = (val == 0);
        // Update the 'previousValIsZero' flag for the next iteration.

    }

    double probability = count / (generationsNo * 1.0);
    // Calculate the probability of two consecutive zero bytes based on the 'count' and 'generationsNo'.

    cout << "The probability of two consecutive val bytes being zero " << generationsNo << " times is: "
         << probability << endl;
}

// RC4 Key-Scheduling Algorithm
void KSA(unsigned char S[256], const string& key) {
    // The 'S' array in RC4 is represented as 'unsigned char' for memory efficiency,
    // as it only needs to store values in the range [0, 255]. Using 'unsigned char'
    // conserves memory compared to using 'int' and is more suitable for bitwise operations.


    // Initialize the S array with values from 0 to 255
    for (int i = 0; i < 256; i++) {
        S[i] = static_cast<unsigned char>(i);
    }

    int j = 0;
    // Iterate over the entire S array to shuffle its elements based on the provided key
    for (int i = 0; i < 256; i++) {
        // Calculate a new value for 'j' by adding the current 'j', the value of 'S[i]', and a key element.
        // 'key[i % key.length()] - '0'' converts a character digit to its integer value (0 or 1).
        j = (j + S[i] + key[i % key.length()] - '0') % 256;
        swap(S[i], S[j]);
    }
}

// Calculate the Hamming distance between two binary strings of bytes.
// The Hamming distance is the count of differing bits between the two strings.
// It's calculated by XORing each bit in the first string with the corresponding bit in the second string
// and then summing all the differing bits. Finally, the result is divided by the string length.
int HammingDistance(const unsigned char str1[], const unsigned char str2[], int length) {
    int differingBits = 0;  // Initialize a counter to keep track of differing bits.

    // Iterate through the bytes of the strings
    for (int i = 0; i < length; i++) {
        // Iterate through the bits (8 bits in a byte)
        for (int bit = 0; bit < 8; bit++) {
            // Extract the corresponding bit from each string and compare them.
            if (((str1[i] >> bit) & 1) != ((str2[i] >> bit) & 1)) {
                differingBits++;  // Increment the differing bits count when a difference is found.
            }
        }
    }

    return differingBits;  // Return the Hamming distance as the count of differing bits.
}

// This function demonstrates a related key attack on the RC4 encryption algorithm.
// It generates two related 128-bit keys, where the second key differs from the first
// by flipping a single random bit. It then initializes two RC4 internal states using
// the key-scheduling algorithm (KSA) for each of the two keys. Finally, it calculates
// the Hamming distance between the two internal states to measure their difference.
void relatedKeyAttack() {
    const int keyLength = 128;
    unsigned char key1[keyLength];
    unsigned char key2[keyLength];

    // Generate a random 128-bit key for key1
    for (int i = 0; i < keyLength; i++) {
        key1[i] = rand() % 2;
    }

    // Initialize key2 as a copy of key1
    for (int i = 0; i < keyLength; i++) {
        key2[i] = key1[i];
    }

    // Flip a random bit in key2
    int randomIndex = rand() % keyLength;
    key2[randomIndex] = 1 - key2[randomIndex];

    unsigned char S1[256];
    unsigned char S2[256];

    // Call the KSA function to initialize S1 and S2 using the key and key2
    KSA(S1, string(key1, key1 + keyLength));
    KSA(S2, string(key2, key2 + keyLength));

    // Calculate the Hamming distance between the two RC4 internal states
    int differingBits = HammingDistance(S1, S2, 256);

    cout << "Hamming Distance between two related keys: " << differingBits << endl;
    cout << "Percentage Difference: " << static_cast<double>(differingBits) / (256 * 8) * 100 << "%" << endl << endl;
}

int main(){
    int Key[128], S[256], T[256];

    int choice;
    do{
        // Display the RC4 Encryption Menu
        cout << "RC4 Encryption Menu:" << endl;
        cout << "1. Set a custom 128-bit key" << endl;
        cout << "2. Generate a random 128-bit key" << endl;
        cout << "3. Perform various tests to prove weaknesses in the RC4 algorithm" << endl;
        cout << "4. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            // Allow the user to enter a custom 128-bit key
            cout <<endl << "Enter a custom 128-bit key (0s and 1s): ";
            for (int i = 0; i < 128; i++) {
                cin >> Key[i];
            }
            cout << endl;
            break;
        case 2:
            // Generate a random 128-bit key
            generateRandomKey(Key);
            cout << endl<<"Random key generated successfully!" << endl << endl;
            break;
        case 3:
            // Perform various tests to prove weaknesses in the RC4 algorithm
            cout << endl <<"Performing various tests to prove weaknesses in the RC4 algorithm" << endl << endl;
            cout << "First test: " << endl << endl;
            // I chose 256 because it's probability is the same as the true value which is 2/256.0
            probabilityOfSecondZero(Key, S, T, 256);

            // I chose 10000 because it was mentioned in the homework description.
            probabilityOfSecondZero(Key, S, T, 10000);
            cout << "The actual value 2/256 is: " << 2/256.0 << endl << endl;

            cout << "Second test:" << endl; 
            // Second test: Probability of two consecutive zero bytes.
            probabilityOfTwoZeros(Key, S, T, 130000);
            // I chose 130000 because it's probability is the more likely be near to the true value which is 2/(256^2) + 1/(256^3)

            probabilityOfTwoZeros(Key, S, T, 1000000);
            // I chose 1000000 because it was mentioned in the homework description.

            cout << "The actual value 2/(256^2) + 1/(256^3) is: " <<  2.0/pow(256,2) + 1.0/pow(256,3) << endl << endl;

            cout << "Third test:" << endl ;
            // Third test: Related key attacks and Hamming distance.
            relatedKeyAttack();
            // Create new key that it's values are the same as the original one, then choose random bit of the 
            // the second key to flib it so the different between them is 1 bit.
            // Then generate and initialize RC4 internal states for each key, and calculate the Hamming distance between them.            break;
        case 4:
            cout << "Goodbye!" << endl;
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
        }
    } while (choice != 4);
    return 0;
}
