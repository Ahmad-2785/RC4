#include <iostream>
#include <cmath>

using namespace std;

void generateRandomKey(int Key[128]){
    // Function to generate a random 128-bit key in binary, just 0s and 1s, using random function
    for (int i = 0; i < 128; i++){
        // To be sure that the result is either 0 or 1
        Key[i] = rand() % 2;
    }
}

void probabilityOfSecondZero(const int Key[128], int S[256], int T[256], int generationsNo){
    // Function to calculate the probability of the second byte being zero in a sequence
    // Initialize S and T arrays
    for (int i = 0; i < 256; i++) {
        // Set the S values to be from 0 to 255
        S[i] = i;
        // Here the 128 is the length of the key
        T[i] = Key[i % 128];
    }

    // Initialize variables i, j, t, val, and count.
    int i = 0, j = 0, t, val, count = 0;
    for (int iter = 0; iter < generationsNo; iter++){
        // Loop for 'generationsNo' iterations, which represents the number of generations
        // of pseudo-random bytes to generate (The number of times to generate 2 bytes)

        // This inner loop iterates twice to perform two bytes.
        for (int n = 0; n < 2; n++){
            i = (i + 1) % 256;
            // Update variable 'i' by incrementing it and ensuring it wraps around within the range [0, 255].

            j = (j + S[i]) % 256;
            // Update variable 'j' using the value from the 'S' array and wrapping it within [0, 255].

            swap(S[i], S[j]);
            t = (S[i] + S[j]) % 256;
            // Calculate variable 't' by adding 'S[i]' and 'S[j]' and wrapping it within [0, 255].

            val = S[t];
            // Get the pseudo-random byte value 'val' from the 'S' array at position 't'.

        }
        // When we out of the inner loop the value in val is the second generated byte, so we test if it's 0
        if (val == 0)
            count++;
    }
    // Output the probability of generating 2 bytes with the second one being zero
    cout << "The probability of generating 2 bytes the second one being zero " << generationsNo << " times : "
         << count / (generationsNo * 1.0) << endl; 
    // We divide the number of having second byte equal to 0 on the number of generated keys.
}

void probabilityOfTwoZeros(const int Key[128], int S[256], int T[256], int generationsNo){
    // generationsNo: the number of bytes to be generated
    // Initialize the S and T arrays with values from the provided 'Key' and sequence numbers
    for (int i = 0; i < 256; i++) {
        S[i] = i;
        T[i] = Key[i % 128];
    }

    int i = 0, j = 0, t, val, count = 0;
    // Initialize variables for the RC4 algorithm and a counter for occurrences of two consecutive zeros.
    bool previousValIsZero = false;
    // A boolean flag to keep track of whether the previous 'val' was zero.

    for (int n = 0; n < generationsNo; n++){
        // Loop for 'generationsNo' iterations to generate pseudo-random bytes.

        i = (i + 1) % 256;
        // Update variable 'i' by incrementing it and ensuring it wraps around within the range [0, 255].

        j = (j + S[i]) % 256;
        // Update variable 'j' using the value from the 'S' array and wrapping it within [0, 255].

        swap(S[i], S[j]);
        t = (S[i] + S[j]) % 256;
        // Calculate variable 't' by adding 'S[i]' and 'S[j]' and wrapping it within [0, 255].

        val = S[t];
        // Get the pseudo-random byte value 'val' from the 'S' array at position 't'.

        if (val == 0 && previousValIsZero){
            // Check if the current 'val' is zero and if the previous 'val' was also zero.
            count++; // Increment the 'count' to track the occurrence of two consecutive zeros.
        }
        previousValIsZero = (val == 0);
        // Update the 'previousValIsZero' flag for the next iteration.

    }

    double probability = count / (generationsNo * 1.0);
    // Calculate the probability of two consecutive zero bytes based on the 'count' and 'generationsNo'.

    cout << "The probability of two consecutive val bytes being zero " << generationsNo << " times is: "
         << probability << endl;
}

int hammingDistance(const int Key1[128], const int Key2[128]){

    // Hamming Distance is calculated between two outputs by XORing each bit in the first string with the
    // corresponding bit in the second string and then summing all the ones

    // but we can have the same result if we comparing the equality between the corresponding bit in the keys


    // Calculate the Hamming distance between two 128-bit keys, 'Key1' and 'Key2'.
    int distance = 0; // Initialize the distance to zero.

    for (int i = 0; i < 128; i++){
        // Iterate through each bit of the 128-bit keys.

        distance += (Key1[i] != Key2[i]);
        // If the corresponding bits of 'Key1' and 'Key2' are different, increment the 'distance'.
        // This operation counts the number of differing bits between the keys.
    }

    return distance; // Return the calculated Hamming distance.
}

void generateBytes(int Key[], int generationsNo, int generatedBytes[]){
    // generationsNo :  the number of generation bytes
    // Generate pseudo-random bytes using the RC4 algorithm with the provided 'Key'.

    int S[256], T[256];
    // Initialize two arrays, 'S' and 'T', which are crucial for the RC4 algorithm.

    for (int i = 0; i < 256; i++) {
        // Initialize arrays 'S' and 'T' based on the provided 'Key'.
        S[i] = i;               // Initialize 'S' with sequential values [0, 255].
        T[i] = Key[i % 128];    // Initialize 'T' by repeating the 'Key' cyclically.
    }

    int i = 0, j = 0, t;
    for (int n = 0; n < generationsNo; n++){
        // Loop 'generationsNo' times to generate pseudo-random bytes.

        i = (i + 1) % 256;
        // Update variable 'i' by incrementing it and ensuring it wraps around within the range [0, 255].

        j = (j + S[i]) % 256;
        // Update variable 'j' using the value from the 'S' array and wrapping it within [0, 255].

        swap(S[i], S[j]);
        t = (S[i] + S[j]) % 256;
        // Calculate variable 't' by adding 'S[i]' and 'S[j]' and wrapping it within [0, 255].

        generatedBytes[n] = S[t];
        // Store the generated pseudo-random byte 'S[t]' in the 'generatedBytes' array.
    }
}

void relatedKeyAttacks(int Key[128]){
    // Simulate a related key attack on the RC4 algorithm with the provided 'Key'.

    int Key2[128];
    // Create a second key, 'Key2,' to perform a related key attack.

    for (int i = 0; i < 128; i++){
        // Copy the values from 'Key' to 'Key2.'
        Key2[i] = Key[i];
    }

    int randomIndex = rand() % 128;
    // Generate a random index within the range [0, 127] to select a bit to flip in 'Key2.'

    Key2[randomIndex] = 1 - Key2[randomIndex];
    // Perform a related key attack by flipping the bit at the randomly selected index in 'Key2.'

    int size = 10000;
    int generatedBytes1[size], generatedBytes2[size];
    // Initialize arrays to store the generated bytes with the original 'Key' and 'Key2.'
    // We want to generate 10000 byte for each key

    generateBytes(Key, size, generatedBytes1);
    // Generate pseudo-random bytes using the original 'Key' and store them in 'generatedBytes1.'

    generateBytes(Key2, size, generatedBytes2);
    // Generate pseudo-random bytes using 'Key2' (related key) and store them in 'generatedBytes2.'

    int distance = hammingDistance(generatedBytes1, generatedBytes2);
    // Calculate the Hamming distance between the generated bytes using the two keys.

    cout << "Hamming Distance between two random keys: " << distance / (size*1.0) << endl << endl;
    // Output the normalized Hamming distance, which represents the difference between the two key sequences.
}

int main(){
    int Key[128], S[256], T[256];

    int choice;
    do{
        // Display the RC4 Encryption Menu
        cout << "RC4 Encryption Menu:" << endl;
        cout << "1. Set a custom 128-bit key" << endl;
        cout << "2. Generate a random 128-bit key" << endl;
        cout << "3. Perform various tests to prove weaknesses in the RC4 algorithm" << endl;
        cout << "4. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            // Allow the user to enter a custom 128-bit key
            cout <<endl << "Enter a custom 128-bit key (0s and 1s): ";
            for (int i = 0; i < 128; i++) {
                cin >> Key[i];
            }
            cout << endl;
            break;
        case 2:
            // Generate a random 128-bit key
            generateRandomKey(Key);
            cout << endl<<"Random key generated successfully!" << endl << endl;
            break;
        case 3:
            // Perform various tests to prove weaknesses in the RC4 algorithm
            cout << endl <<"Performing various tests to prove weaknesses in the RC4 algorithm" << endl << endl;
            cout << "First test: " << endl << endl;
            // I chose 256 because it's probability is the same as the true value which is 2/256.0
            probabilityOfSecondZero(Key, S, T, 256);

            // I chose 10000 because it was mentioned in the homework description.
            probabilityOfSecondZero(Key, S, T, 10000);
            cout << "The actual value 2/256 is: " << 2/256.0 << endl << endl;

            cout << "Second test:" << endl; 
            // Second test: Probability of two consecutive zero bytes.
            probabilityOfTwoZeros(Key, S, T, 130000);
            // I chose 130000 because it's probability is the more likely be near to the true value which is 2/(256^2) + 1/(256^3)

            probabilityOfTwoZeros(Key, S, T, 1000000);
            // I chose 1000000 because it was mentioned in the homework description.

            cout << "The actual value 2/(256^2) + 1/(256^3) is: " <<  2.0/pow(256,2) + 1.0/pow(256,3) << endl << endl;

            cout << "Third test:" << endl ;
            // Third test: Related key attacks and Hamming distance.
            relatedKeyAttacks(Key);
            // Create new key that it's values are the same as the original one, then choose random bit of the 
            // the second key to flib it so the different between them is 1 bit.
            // Then generate 10000 byte from each key, and calculating the hamming distance for them
            break;
        case 4:
            cout << "Goodbye!" << endl;
            break;
        default:
            cout << "Invalid choice. Please try again." << endl;
        }
    } while (choice != 4);
    return 0;
}
